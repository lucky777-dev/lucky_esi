\input{../common/header.tex}
\input{../common/cmds.tex}

\title{Ch. 4 - Types structurés}

\begin{document}
\input{../common/front.tex}

\section{Introduction}

\begin{frame}
\frametitle{Les différents types}
\begin{itemize}[<+->]
\item En \texttt{C} / \cpp, «~tout~» a un type
	\begin{itemize}
	\item Objets, références, fonctions et expressions
	\end{itemize}
\item Il existe deux grandes catégories de types
	\begin{enumerate}
	\item Types de base
		\begin{itemize}
		\item \lstinline|void|, \lstinline|nullptr_t|, arithmétiques, \lstinline|bool|
		\end{itemize}
	\item Types structurés
		\begin{itemize}
		\item Références, pointeurs, tableaux, fonctions, énumérations et classes
		\end{itemize}
	\end{enumerate}
\item On n'a pas abordé les classes (et «~variantes~») et énumérations
\item Énumération : stocke un ensemble fini de valeurs constantes
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Paradigme orienté objet (1/2)}
\begin{itemize}[<+->]
\item Modélisation des composants d'un programme sous forme d'objets
\item Les objets sont instanciés à partir d'un modèle conceptuel : la classe
\item Les objets ont tous des caractéristiques communes
\end{itemize}
\begin{exampleblock}<+->{Exemple}
	\begin{itemize}[<+->]
	\item Tous les animaux ont des pattes
%	\item Tous les insectes ont six pattes
	\item Tous les mammifères ont 4 pattes et des mamelles
	\item Les humains sont des mammifères avec 2 mamelles et un nom
	\end{itemize}
\end{exampleblock}
\begin{itemize}[<+->]
\item Un objet est donc une instance d'une classe aux caractéristiques particulières
	\begin{itemize}
	\item \texttt{abs} est un humain (nom : \lstinline|"Romain"|)
	\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Paradigme orienté objet (2/2)}
\begin{itemize}[<+->]
\item Chaque objet possède des données qui lui sont propres
	\begin{itemize}
	\item Attributs
	\end{itemize}
\item Chaque objet peut réaliser plusieurs fonctionnalités, dépendant de ses attributs
	\begin{itemize}
	\item Fonctions membres
	\end{itemize}
\item Les attributs ne sont pas « visibles » en dehors de la classe
	\begin{itemize}
	\item Encapsulation
	\end{itemize}
\item Un objet peut posséder plusieurs types « hiérarchiques »
	\begin{itemize}
	\item Héritage
	\end{itemize}
\item Conversion implicite entre types « hiérarchiques » compatibles
	\begin{itemize}
	\item Polymorphisme
	\end{itemize}
\item Chaque objet est typé
	\begin{itemize}
	\item En l'absence des relations ci-dessus, impossible de substituer un objet de type \texttt{A} par un objet de type \texttt{B}
	\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Exemple}
\begin{center}
\begin{tikzpicture}[scale=.5]
	\draw[fill=blue!40,rounded corners=2mm] (-2,-2) rectangle (2,0.5);
	\node at (0,0) {\small Animal};
	\draw (-2,-0.5) -- (2,-0.5);
	\node[anchor=west] at (-2,-1.5) {\tiny\texttt{-nbPattes}};	
	
	\draw[fill=blue!40,rounded corners=2mm] (-6,-7) rectangle (-2,-4);
	\node at (-4,-4.5) {\small Mammifère};
	\draw (-6,-5) -- (-2,-5);
	\node[anchor=west] at (-6,-6) {\tiny\texttt{-nbPattes = 2}};	
	\node[anchor=west] at (-6,-6.5) {\tiny\texttt{-nbMamelles}};	
	
	\draw[fill=blue!40,rounded corners=2mm] (-6,-12) rectangle (-2,-9.5);
	\node at (-4,-10) {\small Humain};
	\draw (-6,-10.5) -- (-2,-10.5);
	\node[anchor=west] at (-6,-11.5) {\tiny\texttt{-nbMamelles}};
	
	\draw[fill=blue!40,rounded corners=2mm] (6,-6.5) rectangle (2,-4);
	\node at (4,-4.5) {\small Insecte};
	\draw (6,-5) -- (2,-5);
	\node[anchor=west] at (2,-6) {\tiny\texttt{-nbPattes=6}};
	
	\draw[->,thick,>=stealth] (-4,-4) -- (-4,-3) -- (0,-3) -- (0,-2);
	\draw[->,thick,>=stealth] (4,-4) -- (4,-3) -- (0,-3) -- (0,-2);
	\draw[->,thick,>=stealth] (-4,-9.5) -- (-4,-7);
	
	\node[anchor=west] at (1,-9) {\small \texttt{Insecte i} $\leftarrow$\ \texttt{nouvel Insecte} };
	\node[anchor=west] at (1,-10) {\small \texttt{Animal a} $\leftarrow$\ \texttt{nouvel Insecte} };
\end{tikzpicture}
\end{center}
\end{frame}

\section{Types structurés en \texttt{C}}

\begin{frame}
\frametitle{Limitations}
\begin{itemize}[<+->]
\item Pas de classes, pas d'héritage
	\begin{itemize}
	\item Mais on a quand même une manière de structurer le code
	\end{itemize}
\item Les \lstinline|struct| et \lstinline|union| permettent de déclarer des « paquets » de données
\item On peut définir des fonctions \emph{indépendantes} prenant en paramètres des \lstinline|struct| ou \lstinline|union|
	\begin{itemize}
	\item Pas de fonctions membres
	\item On ne peut pas écrire \lstinline|maFraction.add(f2)|
	\end{itemize}
\item On peut effectuer une certaine généricité avec la conversion implicite des pointeurs vers \lstinline|void*|
\item Définir une \lstinline|struct| ou \lstinline|union| ne définit pas d'alias de type associé
	\begin{itemize}
	\item Il faut explicitement faire un \lstinline|typedef|
	\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}[containsverbatim]
\frametitle{Illustration}
\begin{itemize}
\item Fichier \texttt{typedef.c}
\end{itemize}
\begin{lstlisting}
struct A {};
typedef struct A A; //comment

union B {};
typedef union B B; //comment

//void print_addr1(struct A* a)
void print_addr1(A * a)
{
    printf("%p\n", a);
}

//void print_addr2(union B* b)
void print_addr2(B * b)
{
    printf("%p\n", b);
}

int main()
{
    A a; B b;
    //struct A a; union B b;
    print_addr1(&a);
    print_addr2(&b);
}
\end{lstlisting}
\end{frame}

\subsection{Structures}

\begin{frame}
\frametitle{Structure}
\begin{itemize}[<+->]
\item Structure de donnée de champs non contigus.
	\begin{itemize}
	\item Pas de possibilité de parcours mémoire.
	\end{itemize}
\item Déclaration via le mot-clé \lstinline|struct|.
\item Pas d'initialisation de champs à la déclaration d'une variable.
	\begin{itemize}
	\item Pas de constructeur : valeurs indéterminées.
	\end{itemize}
\item Transmission par valeur : pas de constructeur de recopie.
	\begin{itemize}
	\item Attention aux pointeurs !
	\end{itemize}
\item Affectation possible entre structures de même type uniquement.
	\begin{itemize}
	\item Même si les deux structures ont les mêmes champs, pas de cast possible.
	\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Initialisation}
\begin{itemize}[<+->]
\item Pas de constructeur
\end{itemize}
\begin{exampleblock}<+->{Initialisation implicite}
	\begin{itemize}[<+->]
	\item Les valeurs des attributs dépendent de la classe d'allocation (cf. Ch. 5)
	\item \lstinline|point p;|
	\end{itemize}
\end{exampleblock}
\begin{exampleblock}<+->{Initialisation explicite}
	\begin{itemize}[<+->]
	\item Affectation avec \texttt{= \{ ... \}}
	\item Les attributs manquants sont mis à zéro
	\end{itemize}
\end{exampleblock}
\begin{itemize}[<+->]
\item On peut assigner des valeurs par affectation des attributs
	\begin{itemize}
	\item \lstinline|p.x = 2; p.y = 3;|
	\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}[containsverbatim]
\frametitle{Exemple}
\begin{itemize}
\item Fichier \texttt{point.c}
\end{itemize}
\begin{lstlisting}
struct point
{
	double x, y;	
};

struct point2
{
	double x, y;	
};

typedef struct point point;
typedef struct point2 point2;

double dist(point p1, point p2)
{	
	return sqrt((p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y)); 
}
\end{lstlisting}
\end{frame}

\begin{frame}[containsverbatim]
\frametitle{Exemple}
\begin{itemize}
\item Fichier \texttt{point.c}
\end{itemize}
\begin{lstlisting}
int main()
{
	point p;

	printf("%f %f\n", p.x, p.y);//undefined

	p.x = p.y = 0;

	point p2 = {1, 1}; //try with = {1}
	printf("%f %f\n", p2.x, p2.y);

	printf("%f\n", dist(p, p2));

	point2 brol;
	//point p3 = (point)brol;
	//dist(p1, brol); //no conversion
}
\end{lstlisting}
\end{frame}

\subsection{Unions}

\begin{frame}
\frametitle{Union}
\begin{itemize}[<+->]
\item Déclaration et utilisation similaire aux structures
\item Différence majeure : la mémoire est partagée entre \emph{tous} les champs
\item Déclaration via le mot-clé \lstinline|union|.
\item Idée : si une union possède un champ X et un champ Y, elle stocke \emph{soit} un X, \emph{soit} un Y.
\item La taille d'une union est d'au moins la taille du plus grand champ.
\item Si on affecte une valeur à un champ, la zone de mémoire partagée est modifiée
%	\begin{itemize}
%	\item Les autres sont modifiés aussi.
%	\end{itemize}
\end{itemize}
\begin{block}<+->{Hygiène de programmation}
	\begin{itemize}[<+->]
	\item Éviter
	\end{itemize}
\end{block}
\end{frame}

\begin{frame}[containsverbatim]
\frametitle{Exemple (1/2)}
\begin{itemize}
\item Fichier \texttt{union.c}
\end{itemize}
\begin{lstlisting}
union Data 
{
   int i;
   float f;
   char str[20];
};
 
int main( ) 
{
   union Data data;        

   data.i = 10;
   printf( "data.i : %d\n", data.i);
   printf( "data.f : %f\n", data.f);
   printf( "data.str : %s\n", data.str);
   
   data.f = 220.5;
   printf( "data.i : %d\n", data.i);
   printf( "data.f : %f\n", data.f);
   printf( "data.str : %s\n", data.str);
   
   strcpy( data.str, "C Programming");
   printf( "data.i : %d\n", data.i);
   printf( "data.f : %f\n", data.f);
   printf( "data.str : %s\n", data.str);
}

\end{lstlisting}
\end{frame}

\subsection{Champs de bits}

\begin{frame}
\frametitle{Champs de bits}
\begin{itemize}[<+->]
\item Le \texttt{C} possède des opérateurs permettant de travailler sur les motifs binaires (\cpp aussi).
	\begin{itemize}
	\item \texttt{|}, \texttt{\&}, \texttt{<<}, \texttt{>>}
	\end{itemize}
\item Le langage permet de définir, au sein des structures, des variables occupant un nombre défini de bits.
	\begin{itemize}
	 \item Les champs de bits
	\end{itemize}
\item Seul cas d'un type de taille non multiple d'un byte
\item Utiles pour :
	\begin{itemize}
	\item Compacter l'information : $0 \leqslant i \leqslant 15$ tient sur 4 bits au lieu de 16
	\item Parcourir un motif binaire en mémoire
	\end{itemize}
\item Syntaxe des structures
	\begin{itemize}
	\item \texttt{T t : s;} : le champ \texttt{t} de type \texttt{T} occupe \texttt{s} bits.	
	\item \texttt{T : s;} : On saute \texttt{s} bits.
	\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Types autorisés}
\begin{itemize}[<+->]
\item Trois uniques types d'attributs autorisés
	\begin{enumerate}
	\item Avec \lstinline|unsigned int|, \lstinline|unsigned int b:3;| $\in [0,7]$
	\item Avec \lstinline|signed int|, \lstinline|signed int b:3;| $\in [-4,3]$
	\item Avec \lstinline|int|, \lstinline|int b:3;| $\in [0,7]$ ou $\in [-4,3]$ 
	\item Avec \lstinline|bool|, \lstinline|int b:1;| $\in [0,1]$ (\lstinline|true| et \lstinline|false|)
	\end{enumerate}
\item Unique cas où \lstinline|int| $\neq$ \lstinline|signed int|
\item On ne peut pas 
	\begin{itemize}
	\item créer de pointeurs de champs de bits
	\item utiliser \lstinline|sizeof| avec les champs de bits
	\end{itemize}
\end{itemize}
\begin{block}<+->{Hygiène de programmation}
	\begin{itemize}[<+->]
	\item Éviter
	\end{itemize}
\end{block}
\end{frame}

\begin{frame}[containsverbatim]
\frametitle{Exemple}
\begin{lstlisting}
struct state
{
	unsigned rdy : 1;
	unsigned ok1 : 1;
	int data1    : 5;
	int          : 3;
	unsigned ok2 : 1;
	int data2    : 4;
};
\end{lstlisting}
\begin{center}
\begin{tikzpicture}[scale=.7]
\draw (0,0) -- (16,0);
\draw (0,1) -- (16,1);
\draw (16,0) -- (16,1);
\foreach \i in {0, ..., 15}
{
	\draw (\i,0) -- (\i,1);
	\pgfmathtruncatemacro{\num}{15-\i}
	\node at (\i+0.5,1.5) {$\num$};
}
\draw[<->] (1,-0.5) -- (5,-0.5);
\draw[<->] (5,-0.5) -- (6,-0.5);
%\draw[<->] (6,-0.5) -- (9,-0.5);
\draw[<->] (9,-0.5) -- (14,-0.5);
\draw[<->] (14,-0.5) -- (15,-0.5);
\draw[<->] (15,-0.5) -- (16,-0.5);
\node at (3,-1) {\texttt{data2}};
\node at (5.5,-1) {\texttt{ok2}};
%\node at (7.5,-1) {\texttt{flag}};
\node at (11.5,-1) {\texttt{data1}};
\node at (14.5,-1) {\texttt{ok1}};
\node at (15.5,-1) {\texttt{rdy}};
\end{tikzpicture}
\end{center}
\end{frame}

\section{Énumérations}

\begin{frame}
\frametitle{Énumération}
\begin{itemize}[<+->]
\item Définit un type initialisable sur un nombre fini non vide de valeurs
	\begin{itemize}
	\item Les énumérateurs ne sont pas des \texttt{lvalue}
	\item On ne peut pas les réaffecter
	\end{itemize}
\item Les énumérateurs sont définis globalement
\item Associe une valeur \lstinline|int| à chacuns des énumérateurs
\item Possibilité de spécifier explicitement ces valeurs.
	\begin{itemize}
	\item Possibilité d'affecter une même valeur à plusieurs énumérateurs.
%	\item Mais interdiction d'avoir plusieurs énumérateurs de même nom dans des énumérations différentes.
	\end{itemize}
\item Possibilité d'affecter une valeur entière hors des valeurs possibles.
	\begin{itemize}
	\item Résultat dépendant du compilateur.
	\end{itemize}
\item Possibilité de tests avec \lstinline|switch|
\item Maintenez un code \emph{lisible}
\end{itemize}
\end{frame}

\begin{frame}[containsverbatim]
\frametitle{Exemple}
\begin{itemize}
\item Fichier \texttt{enum.c}
\end{itemize}
\begin{lstlisting}
enum couleur {	rouge, vert, bleu   };
enum boolean {vrai = 1, faux = 0};

main()
{
	enum couleur c1 = rouge;
	enum couleur c2 = c1;

	printf("%i\n", c1);
	printf("%i\n", c2);

	int n = bleu;
	int p = vert * n + 2;

	printf("%i\n",n);
	printf("%i\n",p);
	//vert = n;
	
	enum couleur c3 = faux;
	enum boolean brol = 3 * c2 + 4;

	printf("%i\n",c3);
	printf("%i\n",brol);
}
\end{lstlisting}
\end{frame}

\begin{frame}[containsverbatim]
\frametitle{Exemple}
\begin{itemize}
\item Fichier \texttt{enum2.c}
\end{itemize}
\begin{lstlisting}
typedef enum color { RED, GREEN, BLUE} color;

enum Foo { A, B, C=10, D, E=1, F, G=F+C}; //don't try this at home
//A=0, B=1, C=10, D=11, E=1, F=2, G=12

int main()
{
    color c = RED;
    
    switch(c) 
    {
        case RED   : printf("red\n"); break;
        case GREEN : printf("green\n"); break;
        case BLUE  : printf("blue\n"); break;
    }
}
\end{lstlisting}
\end{frame}

\begin{frame}
\frametitle{En \cpp}
\begin{itemize}[<+->]
\item Possibilité de définir des énumérations fortement typées
\item Déclaration avec \lstinline|enum class NAME { ... };|
\item Possibilité de choisir le type sous-jacent des énumérateurs avec \lstinline|enum class NAME : TYPE { ... };|
	\begin{itemize}
	\item Doit posséder une conversion implicite vers \lstinline|int|
	\end{itemize}
\item Dans tous les cas, pas de conversion implicites vers les entiers
	\begin{itemize}
	\item On peut obtenir la valeur de l'énumérateur avec \lstinline|static_cast|
	\end{itemize}
\item Accès aux énumérateurs avec l'opérateur de résolution de portée
\item Possibilité de surcharge d'opérateur (cf. Ch. 8)
\end{itemize}
\begin{block}<+->{Hygiène de programmation}
	\begin{itemize}[<+->]
	\item Éviter les énumérations non fortement typées en \cpp
	\end{itemize}
\end{block}
\end{frame}

\begin{frame}[containsverbatim]
\frametitle{Exemple}
\begin{itemize}
\item Fichier \texttt{enum.cpp}
\end{itemize}
\begin{lstlisting}
enum class Color { red, green = 20, blue };

enum class altitude : char
{ 
     high='h',
     low='l'
}; 

int main()
{
    Color r = Color::blue;
    switch(r)
    {
        case Color::red  : cout << "red" << endl;   break;
        case Color::green: cout << "green" << endl; break;
        case Color::blue : cout << "blue" << endl;  break;
    }
    
    // int n = r; 
    int n = static_cast<int>(r); // OK, n = 21
}
\end{lstlisting}
\end{frame}

\section{Classes}

\begin{frame}
\frametitle{\cpp\ : les classes}
\begin{itemize}[<+->]
\item Les classes permettent de définir un ensemble variables de différents types regroupées sous un même nom
	\begin{itemize}
	\item Mot-clé \lstinline|struct| et \lstinline|class|
	\end{itemize}
\item En \cpp, on peut définir des fonctions membres dans des classes
	\begin{itemize}
	\item Méthodes en \java
	\end{itemize}
\item Accès aux membres / attributs avec \texttt{.}
	\begin{itemize}
	\item Avec \texttt{->} via un pointeur (p. ex., \lstinline|this|)
	\end{itemize}
\end{itemize}
\begin{exampleblock}<+->{Différences entre classes et structures}
	\begin{itemize}[<+->]
	\item En l'absence de spécificateur d'accès,
		\begin{enumerate}
		\item les membres d'une \lstinline|class| sont privés, ceux d'une \lstinline|struct| sont publics
		\item les membres d'une mère au sein d'une fille sont privés dans une \lstinline|class|, publics dans une \lstinline|struct|
		\end{enumerate}
	\end{itemize}	
\end{exampleblock}
\end{frame}

\begin{frame}[containsverbatim]
\frametitle{Exemple classe}
\begin{itemize}
\item Fichier \texttt{point-class.cpp}
\end{itemize}
\begin{lstlisting}
class point
{
	double x, y;

	public:
		point(int x, int y)
		{
			this->x = x;
			this->y = y;
		}

		inline double getX()
		{
			return x;
		}

		inline double getY()
		{
			return y;
		}		

		double dist(point p)
		{
			return sqrt((x - p.x)*(x - p.x)+(y - p.y)*(y - p.y));
		} 	
};
\end{lstlisting}
\end{frame}

\begin{frame}[containsverbatim]
\frametitle{Exemple classe}
\begin{itemize}
\item Fichier \texttt{point-struct.cpp}
\end{itemize}
\begin{lstlisting}
struct point
{			
	point(int x, int y)
	{
		this->x = x;
		this->y = y;
	}

	inline double getX()
	{
		return x;
	}

	inline double getY()
	{
		return y;
	}		

	double dist(point p)
	{
		return sqrt((x - p.x)*(x - p.x)+(y - p.y)*(y - p.y));
	} 	

	private:
		double x, y;
};
\end{lstlisting}
\end{frame}

\begin{frame}[containsverbatim]
\frametitle{Utilisation}
\begin{itemize}
\item Fichiers \texttt{point-class.cpp} et \texttt{point-struct.cpp}
\end{itemize}
\begin{lstlisting}
int main()
{
	point p1(1,1);
	//cout << p1.x << " " << p1.y << endl; //ko
	cout << p1.getX() << " " << p1.getY() << endl;	
	point p2(2,2);
	cout << p2.getX() << " " << p2.getY() << endl;
	cout << "dist = " << p1.dist(p2) << endl;
}
\end{lstlisting}
\begin{alertblock}{Remarque}
	\begin{itemize}
	\item Ne pas oublier le '\texttt{;}' après la déclaration d'une classe ou d'une structure
	\end{itemize}
\end{alertblock}
\end{frame}

\begin{frame}
\frametitle{Implémentation et déclarations}
\begin{itemize}[<+->]
\item Souvent, on sépare la déclaration et l'implémentation d'une classe
\item Déclaration dans les headers \texttt{.h}, implémentation dans les sources \texttt{.cpp}
	\begin{itemize}
	\item Fichiers \texttt{.hpp} : headers et sources
	\end{itemize}
\item On définit l'implémentation à l'aide de \texttt{::}
	\begin{itemize}
	\item \lstinline|double point::dist(point p)  \{ ... \}|
	\end{itemize}
\end{itemize}
\begin{exampleblock}<+->{Fonctions \texttt{inline}}
	\begin{itemize}[<+->]
	\item Doivent être implémentés dans la même unité de traduction
		\begin{itemize}
		\item «~Même fichier~»
		\end{itemize}
	\item Si défini complètement au sein d'une classe, union ou structure : implicitement inline
	\end{itemize}
\end{exampleblock}
\end{frame}

\begin{frame}[containsverbatim]
\frametitle{Exemple (1/2)}
\begin{itemize}
\item Fichier \texttt{point-decl-impl.h}
\end{itemize}
\begin{lstlisting}
//no include, no using namespace std;

class point
{
	double x, y;

	public:
		point(int x, int y);
		inline double getX();
		inline double getY();
		double dist(point p);
};

double point::getX()
{
    return x;
}

double point::getY()
{
    return y;
}
\end{lstlisting}
%\begin{itemize}
%\item Fichier \texttt{point-decl-impl.cpp}
%\end{itemize}
%\begin{lstlisting}
%#include "point-decl-impl.h"
%
%point::point(int x, int y)
%{
%    this->x = x;
%    this->y = y;
%}
%
%double point::dist(point p)
%{
%    return sqrt((x - p.x)*(x - p.x)+(y - p.y)*(y - p.y));
%}
%\end{lstlisting}
\end{frame}

\begin{frame}[containsverbatim]
\frametitle{Exemple (2/2)}
\begin{itemize}
\item Fichier \texttt{point-decl-impl.cpp}
\end{itemize}
\begin{lstlisting}
#include "point-decl-impl.h"

point::point(int x, int y) {
    this->x = x;
    this->y = y;
}

double point::dist(point p) {
    return sqrt((x - p.x)*(x - p.x)+(y - p.y)*(y - p.y));
}
\end{lstlisting}
\begin{itemize}
\item Fichier \texttt{point-decl-impl-main.cpp}
\end{itemize}
\begin{lstlisting}
#include <iostream>
#include "point-decl-impl.h"

using namespace std;

int main() {
	point p1(1,1); point p2(2,2);
	cout << p1.getX() << " " << p1.getY() << endl;	
	cout << p2.getX() << " " << p2.getY() << endl;
	cout << "dist = " << p1.dist(p2) << endl;
}
\end{lstlisting}
\end{frame}

\begin{frame}
\frametitle{Fonctions membres constantes}
\begin{itemize}[<+->]
\item Rend une fonction \emph{membre} constante
\item Ajoute le CV-qualifier \lstinline|const| sur la fonction concernée
\item Ne modifie pas \lstinline|this|
	\begin{itemize}
	\item Impossible de modifier un attribut
	\item Impossible d'appeler une fonction non constante
	\end{itemize}
\item Usage du mot-clé \lstinline|const| à la fin du prototype
\item Souvent utilisé pour les getters
%\item Si un objet est \lstinline|const|, on ne peut appeler que des fonctions \lstinline|const| dessus
\item Si définition de deux prototypes (un \lstinline|const| et pas l'autre),
	\begin{itemize}
	\item les objets \lstinline|const| appellent le prototype \lstinline|const|
	\item les autres appellent l'autre
	\end{itemize}
\item Compilatoirement, offre certaines optimisations
\item Surtout utile pour le programmeur
\end{itemize}
\end{frame}

\begin{frame}[containsverbatim]
\frametitle{Exemple}
\begin{itemize}
\item Fichier \texttt{const-class.cpp}
\end{itemize}
\begin{lstlisting}
class A
{
    int i;   
    
    public:
        A(int i) { this->i = i; }
        void set(int i) { this->i = i; }
        int& get() { cout << "g "; return i; }
        const int& get() const { cout << "cg "; return i; }
};

int main()
{
    A a(2);   
    
    a.set(3);
    cout << a.get() << endl;
    a.get() = 5;
    cout << a.get() << endl;
    
    const A ca(42);
    //ca.set(5);
    cout << ca.get() << endl;
}
\end{lstlisting}
\end{frame}

\section{Constructeurs et destructeurs}

\begin{frame}
\frametitle{Introduction}
\begin{itemize}[<+->]
\item Constructeur : appelé à l'instanciation d'un objet
	\begin{itemize}
	\item Allocation de mémoire
	\item Assignation des attributs, pré-traitement, etc.
	\end{itemize}
\item Destructeur : appelé à la destruction de l'objet
	\begin{itemize}
	\item Désallocation de mémoire
	\item Post-traitement, désallocations explicites
	\end{itemize}
\end{itemize}
\begin{exampleblock}<+->{Exemple : écriture dans un fichier}
	\begin{itemize}[<+->]
	\item Création : initialisation avec le chemin vers le fichier, test d'existence, ouverture du fichier
	\item Destruction : vidage des tampons, fermeture du fichier
	\end{itemize}
\end{exampleblock}
\begin{itemize}[<+->]
\item Pas de type de retour, même nom que la classe
	\begin{itemize}
	\item Destructeur préfixé de \texttt{\texttildelow}
	\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Constructeur particuliers}
\begin{itemize}[<+->]
\item On utilise un constructeur à
	\begin{itemize}
	\item l'initialisation(implicite ou non),
	\item la copie (implicite ou non),
	\item la réallocation
	\end{itemize}
\item Pas à l'affectation
%\item Pas de type de retour
%\item Même nom que la classe
\item Possibilité de plusieurs constructeurs
	\begin{itemize}
	\item Constructeur par défaut
	\item Constructeur de recopie
	\item Constructeur de déplacement (cf. Ch. 10)
	\item Constructeur « personnalisé »
	\end{itemize}
\item Règles d'appel particulières en cas d'héritage (cf. Ch. 12)
\end{itemize}
\end{frame}

\begin{frame}[containsverbatim]
\frametitle{Exemple}
\begin{itemize}
\item Fichier \texttt{point-cstr.cpp}
\end{itemize}
\begin{lstlisting}
class point {
	double x, y;
	bool copie;

	public:
		point(int x, int y) {
			this->x = x; this->y = y;
			copie = false;
		
			cout << "Construction de " << x << " " << y << endl;
		}

		point(const point& p) {
			this-> x = p.x; this-> y = p.y;
			copie = true;
		
			cout << "Copie de " << x << " " << y << endl;
		}	

		~point() {
			cout << "Destruction de " << x << " " << y;
			if(copie)
				cout << " (copie)";
			cout << endl;
		}
}
\end{lstlisting}
\end{frame}

\begin{frame}[containsverbatim]
\frametitle{Exemple (2/2)}
\begin{itemize}
\item Fichier \texttt{point-cstr.cpp}
\end{itemize}
\begin{lstlisting}
void sayHello(point p) { //fct indep, try with &, * 
	cout << "Hello Mr point " << p.getX() << " " << p.getY() << endl;
}

int main() {
	point p1(0,0); point p2(1,1);
	cout << p1.getX() << " " << p1.getY() << endl;
	sayHello(p1);
	cout << p2.getX() << " " << p2.getY() << endl;
	cout << "dist = " << p1.dist(p2) << endl;
	
	point p3(p1);//explicit copy
	p3 = p2;	
}
\end{lstlisting}
\begin{alertblock}{Remarques}
	\begin{itemize}
	\item Copies implicites effectuées
	\item Destructions implicites effectuées
	\item Affectation muette
	\end{itemize}
\end{alertblock}
\end{frame}

\subsection{Constructeur par défaut}

\begin{frame}
\frametitle{Constructeur par défaut}
\begin{itemize}[<+->]
\item Constructeur sans paramètres
	\begin{itemize}
	\item Possibilité avec valeurs par défaut
	\end{itemize}
\item Appelé à l'instanciation (cf. Ch. 5)
	\begin{itemize}
	\item Implicitement à la déclaration sans paramètres
	\end{itemize}
\item Si aucun constructeur (quel que soit son «~type~») n'est défini par l'utilisateur, un constructeur par défaut est ajouté à la compilation
	\begin{itemize}
	\item Public, et inline
	\item Instanciation toujours possible
	\end{itemize}
\item Si un constructeur avec paramètres est présent et pas de constructeur par défaut, appeler le constructeur par défaut provoque une erreur de compilation
\item On peut forcer la génération d'un constructeur par défaut avec \lstinline|= default;|
	\begin{itemize}
	\item Même effet qu'un constructeur vide
	\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Suppression de constructeur par défaut}
\begin{itemize}[<+->]
\item On peut empêcher la génération d'un constructeur par défaut avec \lstinline|= delete;|
	\begin{itemize}
	\item Permet de s'assurer que des objets sans constructeurs sont dans des états cohérents
	\end{itemize}
\item On peut également empêcher implicitement la génération dans une classe \texttt{T} si
	\begin{itemize}
	\item \texttt{T} possède un membre de type référence ou constant non initialisé
	\item \texttt{T} possède un membre non initialisé  avec un constructeur par défaut \lstinline|delete|
	\item \texttt{T} hérite d'une classe ayant un constructeur par défaut \lstinline|delete|
	\item \texttt{T} hérite d'une classe ayant un destructeur \lstinline|delete|
	\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}[containsverbatim]
\frametitle{Utilité}
\begin{itemize}
\item Fichier \texttt{delete-cstr.cpp}
\end{itemize}
\begin{lstlisting}
struct A { int i; };
struct AD
{
    int i;
    AD() = delete;
};

int main()
{
    A a1;     //i not init
    A a2{};   //i = 0
    A a3{42}; //i = 42
    
    //AD ad;
    AD ad{};
    AD ad2{42};
}

\end{lstlisting}
\end{frame}

\begin{frame}[containsverbatim]
\frametitle{Appels (1/2)}
\begin{itemize}
\item Fichier \texttt{call-cstr.cpp}
\end{itemize}
\begin{lstlisting}
struct A {
    int x;
    A(int x = 1): x(x) {} // user-defined default constructor
};
 
struct B : A {}; // B::B() implicitly-defined, calls A::A()
 
struct C {
    A a;    
}; // C::C() implicitly-defined, calls A::A()
 
struct D: A {
    D(int y): A(y) {}
}; // D::D() not declared
 
struct E: A {
    E(int y): A(y) {}
    E() = default; // explicitly defaulted, calls A::A()
};
 
struct F {
    int& ref; 
    const int c;    
}; // F::F() is implicitly defined as deleted
\end{lstlisting}
\end{frame}

\begin{frame}[containsverbatim]
\frametitle{Appels (2/2)}
\begin{itemize}
\item Fichier \texttt{call-cstr.cpp}
\end{itemize}
\begin{lstlisting}
int main()
{
    A a;
    B b;
    C c;
//  D d; 
    E e;
//  F f; 
}
\end{lstlisting}
\end{frame}

\subsection{Constructeur de recopie}

\begin{frame}
\frametitle{Constructeur de recopie}
\begin{itemize}[<+->]
\item Appelé quand un paramètre est passé par valeur
	\begin{itemize}
	\item \texttt{T a(b);} (appel explicite)
	\item \texttt{f(a);}, où \texttt{f} est \lstinline|B f(A a)|
	\item \lstinline|return a;| dans une fonction \lstinline|A f(B b)|
	\end{itemize}
\item Constructeur avec un paramètre constant passé par référence
	\begin{itemize}
	\item \lstinline|MaClasse::MaClasse(const MaClasse& c)|
	\end{itemize}
\item Si aucun constructeur de recopie n'est présent, un constructeur de recopie par défaut est ajouté à la compilation
	\begin{itemize}
	\item Public et inline
	\end{itemize}
\item Si un constructeur de recopie avec paramètres est présent et pas de constructeur de recopie par défaut, appeler le constructeur de recopie par défaut provoque une erreur de compilation
\item On peut forcer la génération d'un constructeur de recopie avec \lstinline|= default;|
	\begin{itemize}
	\item Même effet qu'un constructeur vide
	\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Suppression de constructeur de recopie}
\begin{itemize}[<+->]
\item On peut empêcher la génération d'un constructeur de recopie avec \lstinline|= delete;|
	\begin{itemize}
	\item Permet de s'assurer que des objets ne peuvent être copiés
	\item Performance
	\end{itemize}
\item On peut également empêcher implicitement la génération dans une classe \texttt{T} si
	\begin{itemize}
	\item \texttt{T} possède un membre non copiable
	\item \texttt{T} possède un constructeur de déplacement ou opérateur d'assignation-déplacement (cf. Ch. 10)
	\item \texttt{T} hérite d'une classe ayant un constructeur de recopie \lstinline|delete|
	\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}[containsverbatim]
\frametitle{Exemple (1/2)}
\begin{itemize}
\item Fichier \texttt{call-copy.cpp}
\end{itemize}
\begin{lstlisting}
struct A {
    int n;
    A(int n = 1) : n(n) { }
    A(const A& a) : n(a.n) { } 
};
 
void f1(A a) {}
void f2(A& a) {}

A f3()
{
    A a; 
    return a;
}

int main()
{
    A a1(7);
    A a2(a1);  // copy
    A a3 = a2; //copy
    
    f1(a1); //copy
    f2(a1);
    A a4 = f3();
}
\end{lstlisting}
\end{frame}

\begin{frame}[containsverbatim]
\frametitle{Exemple (2/2)}
\begin{itemize}
\item Fichier \texttt{call-copy.cpp}
\end{itemize}
\begin{lstlisting}
struct B
{
    B();
    B(const B&) = delete;
};

void f4(B b) {}
void f5(B& b) {}

/*
B f6()
{
    B b;
    return b;
}*/

int main()
{
    B b;    
    //f4(b);
    f5(b);
    
    //B b2 = f6();
}
\end{lstlisting}
\end{frame}

\subsection{Liste d'initialisation}

\begin{frame}
\frametitle{Principe}
\begin{itemize}[<+->]
\item Permet d'initialiser «~à la volée~» les attributs dans un constructeur
\item Plus efficace (moins de copies temporaires) que dans les accolades
\end{itemize}
\begin{alertblock}<+->{Remarque importante}
	\begin{itemize}[<+->]
	\item Indispensable pour
		\begin{enumerate}
		\item initialiser les attributs constants
		\item initialiser des attributs non initialisables par défaut
		\item initialiser les références
		\item effectuer de la délégation de constructeurs
		\end{enumerate}
	\end{itemize}
\end{alertblock}
\begin{itemize}[<+->]
\item Initialisation avec \texttt{:}, sous la forme d'une liste séparée par des \texttt{,}
\end{itemize}
\end{frame}

\begin{frame}[containsverbatim]
\frametitle{Exemple}
\begin{itemize}
\item Fichier \texttt{point\_init.cpp}
\end{itemize}
\begin{lstlisting}
class point
{
	double x, y;

	public:
		point(int x = 0, int y = 0) : x(x), y(y) {}

		double getX() const
		{
			return x;
		}

		double getY() const
		{
			return y;
		}		

		double dist(point p)
		{
			return sqrt((x - p.x)*(x - p.x)+(y - p.y)*(y - p.y));
		} 	
};
\end{lstlisting}
\end{frame}

\begin{frame}[containsverbatim]
\frametitle{Délégation}
\begin{itemize}
\item Fichier \texttt{deleg.cpp}
\end{itemize}
\begin{lstlisting}
class A
{	
	int i;
	const int k;

	private:
		A() : k(5)
		{
			cout << "Init " << endl;
			//k = 5;
		}	
	
	public:
		A(int x) : A()/*, i(x)*/ 
		{
			i = x;
		}

		void print() { cout << "A : " << i << endl;}
};
\end{lstlisting}
\begin{itemize}
\item Utilisé aussi pour l'appel de superconstructeurs
\end{itemize}
\end{frame}

\begin{frame}[containsverbatim]
\frametitle{Absence de constructeur par défaut}
\begin{itemize}
\item Fichier \texttt{no-cstr.cpp}
\end{itemize}
\begin{lstlisting}
struct A
{
	int i;	
	A(int i) : i(i) {}
};

struct B
{
	A a;
	B(A a) : a(a) {};//ok		
	
	//B(A a)//ko
	//{
	//	this-> a = a;
	//}
};

int main()
{	
	A a(2);
	B b(a);
}
\end{lstlisting}
\end{frame}

\begin{frame}
\frametitle{Header \texttt{initializer\_list.h}}
\begin{itemize}[<+->]
\item Permet d'avoir des arguments «~variables en nombre~» dans les constructeurs
	\begin{itemize}
	\item Aussi dans les fonctions (membres ou non)
	\end{itemize}
\item Instanciation avec les accolades
	\begin{itemize}
	\item \lstinline|vector<int> v = \{1, 2, 3\};|
	\item \texttt{brol.append(\{1,2,3\});}
	\end{itemize}
\item Se comporte comme une liste
	\begin{itemize}
	\item Itérateurs, \texttt{size()}, etc.
	\end{itemize}
\end{itemize}
\begin{exampleblock}<+->{Remarque}
	\begin{itemize}[<+->]
	\item \texttt{objet.fonction(2);} $\neq$ \texttt{objet.fonction(\{2\});}
	\end{itemize}
\end{exampleblock}
\end{frame}

\begin{frame}[containsverbatim]
\frametitle{Exemple}
\begin{itemize}
\item Fichier \texttt{dataset.cpp}
\end{itemize}
\begin{lstlisting}
class DataSet
{
	double sum;
	int count;

	public:
		DataSet() : sum(0), count(0) {}
		DataSet(const initializer_list<double>& data) : DataSet() { update(data); }		

		void update(const initializer_list<double>& data)
		{
			for(double d : data)
			{
				update(d);
			}
		}

		inline void update(double d)
		{
			sum += d;
			count++;
		}		

		inline double mean() const { return sum / count; }
};
\end{lstlisting}
\end{frame}

\begin{frame}
\frametitle{Initialisation explicite : résumé}
\begin{itemize}[<+->]
\item \texttt{A a; B b;}
\item \lstinline|A a(b);| : appel explicite au constructeur
\item \lstinline|A a = b;| : «~conversion~»
	\begin{enumerate}
	\item Opérateur d'affectation surchargé (cf. Ch. 8)
	\item Appel constructeur avec conversion implicite autorisée (cf. Ch. 9)
	\end{enumerate}
\item \lstinline|A a \{b\};| : appel explicite au constructeur, sans conversion implicite
\item \lstinline|A a = \{b\};|
	\begin{itemize}
	\item Si pas de constructeur \texttt{std::initializer\_list}, équivalent à \lstinline|A a {b};|
	\item Sinon, appelle le constructeur \texttt{std::initializer\_list}
	\end{itemize}
\end{itemize}
\end{frame}

\subsection{Destructeur}

\begin{frame}
\frametitle{Destructeur}
\begin{itemize}[<+->]
\item Fonction particulière appelée à la désallocation de l'objet
	\begin{itemize}
	\item Désallocation implicite ou explicite (cf. Ch. 5)
	\item Règles d'appel particulières en cas d'héritage (cf. Ch. 12)
	\end{itemize}
\item Pas de type de retour, pas de paramètres
\item Même nom que la classe, précédé de \texttt{\~}
\item Si aucun destructeur n'est présent, un constructeur par défaut est ajouté à la compilation
	\begin{itemize}
	\item Public et inline
	\end{itemize}
\item Unique (si plusieurs : erreur)
\item On peut forcer la génération d'un constructeur de recopie avec \lstinline|= default;|
	\begin{itemize}
	\item Même effet qu'un constructeur vide
	\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Suppression de destructeur}
\begin{itemize}[<+->]
\item On peut empêcher la génération d'un destructeur avec \lstinline|= delete;|
	\begin{itemize}
	\item Permet de s'assurer que des objets ne peuvent être détruits
	\item Performance
	\end{itemize}
\item On peut également empêcher implicitement la génération dans une classe \texttt{T} si
	\begin{itemize}
	\item \texttt{T} possède un membre non destructible
	\item \texttt{T} hérite d'une classe ayant un destructeur \lstinline|delete|
	\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}[containsverbatim]
\frametitle{Exemple}
\begin{itemize}
\item Fichier \texttt{destr.cpp}
\end{itemize}
\begin{lstlisting}
void open_f(const string& path) {	cout << "Opening " << path << endl;   }

void flush_f(const string& path) {	cout << "Flushing " << path << endl;   }

void close_f(const string& path) {	cout << "Closing " << path << endl;   }

class InputFileStream {
    const string& path;    
      public:
            InputFileStream(const string& path) : path(path) {
                open_f(path);
            }
    
            ~InputFileStream()	{                
                flush_f(path);
                close_f(path);
            }
};

int main()	{
    InputFileStream("brol.txt");
}//désallocation implicite
\end{lstlisting}
\begin{itemize}
\item Autres exemples au chapitre 5
\end{itemize}
\end{frame}

\section{Déclaration, définition et inclusion}

\begin{frame}
\frametitle{Séparation déclaration / définition}
\begin{exampleblock}<+->{Rappel}
	\begin{itemize}[<+->]
	\item Souvent, les déclarations sont séparées des définitions
		\begin{itemize}
		\item Déclarations dans des fichiers \texttt{.h}
		\item Définitions dans des fichiers \texttt{.c} / \texttt{.cpp}
		\item Pas les fonctions \lstinline|inline|
		\end{itemize}
	\item Permet, entre autres, d'éviter les problèmes
		\begin{itemize}
		\item liés à l'ordre des déclarations
		\item liés aux inclusions multiples de fichiers 
		\end{itemize}
	\end{itemize}	
\end{exampleblock}
\begin{itemize}[<+->]
\item Implémentation des fonctions membres à l'aide de l'opérateur de résolution de portée (\cpp)
\end{itemize}
\end{frame}

\begin{frame}[containsverbatim]
\frametitle{Exemple avec fonctions indépendantes}
\begin{itemize}
\item Fichiers \texttt{fct-decl.h}
\end{itemize}
\begin{lstlisting}
void print_str(const char*);
\end{lstlisting}
\begin{itemize}
\item Fichier \texttt{fct-decl.c}
\end{itemize}
\begin{lstlisting}
#include "stdio.h"
#include "fct-decl.h"

void print_str(const char* s)
{
	printf("%s\n", s);
}
\end{lstlisting}
\begin{itemize}
\item Fichier \texttt{fct-decl-main.c}
\end{itemize}
\begin{lstlisting}
#include "fct-decl.h"

int main()
{
	print_str("Hello World!");
}
\end{lstlisting}
\end{frame}

\begin{frame}[containsverbatim]
\frametitle{Exemple \cpp}
\begin{itemize}
\item Fichiers \texttt{point\_decl.h}, \texttt{point\_decl.cpp} et \texttt{point\_decl-main.cpp}
\end{itemize}
\begin{lstlisting}
class point
{
	double x, y;

	public:
		point(double x, double y);
		inline double getX() const;
		inline double getY() const;
		double dist(point p) const;
};
\end{lstlisting}
\begin{lstlisting}
int main()
{
	point p1(1,1);
	//cout << p1.x << " " << p1.y << endl; //ko
	cout << p1.getX() << " " << p1.getY() << endl;	
	point p2(2,2);
	cout << p2.getX() << " " << p2.getY() << endl;
	cout << "dist = " << p1.dist(p2) << endl;
}
\end{lstlisting}
\end{frame}

\begin{frame}[containsverbatim]
\frametitle{Exemple}
\begin{itemize}
\item Fichiers \texttt{point\_decl.h}, \texttt{point\_decl.cpp} et \texttt{point\_decl-main.cpp}
\end{itemize}
\begin{lstlisting}
double point::getX() const
{
	return x;
}

double point::getY() const
{
	return y;
}
\end{lstlisting}
\begin{lstlisting}
#include "point_decl.h"

point::point(double x, double y)
{
	this->x = x;
	this->y = y;
}

double point::dist(point p) const
{
	return sqrt((x - p.x)*(x - p.x)+(y - p.y)*(y - p.y));
} 		
\end{lstlisting}
\end{frame}

\begin{frame}
\frametitle{Inclusions multiples}
\begin{itemize}[<+->]
\item Parfois, des inclusions multiples de fichiers sont nécessaires
	\begin{itemize}
	\item Un maillon de liste chaînée a un attribut maillon (élément suivant de la liste)
	\item Un département est dirigé par un manager, un manager dirige un département
	\end{itemize}
\end{itemize}
\begin{alertblock}<+->{Un problème de taille}
	\begin{itemize}[<+->]
	\item Si un cycle d'attributs apparaît, les objets sont de taille infinie
	\end{itemize}
\end{alertblock}
\begin{itemize}[<+->]
\item Solution : utiliser une adresse et \texttt{\#ifndef} / \texttt{\#define}
\end{itemize}
\end{frame}

\begin{frame}[containsverbatim]
\frametitle{Exemple}
\begin{itemize}
\item Fichier \texttt{mag-dep-pourri.cpp}
\end{itemize}
\begin{lstlisting}
struct Manager
{
	Departement& dpt;
	string nom;
	
	Manager(string nom, Departement& dpt) : nom(nom), dpt(dpt) {}
};

struct Departement
{
	Manager mgr;
	string nom;

	Departement(string nom) : nom(nom) {}
};

int main()
{
	Departement esi("ESI");
	Manager mwi("Willemse", esi);
	esi.mgr = mwi;
}
\end{lstlisting}
\end{frame}

\begin{frame}[containsverbatim]
\frametitle{Exemple}
\begin{itemize}
\item Fichiers \texttt{manager.*}, \texttt{departement.*} et \texttt{mag-dep-main.cpp}
\end{itemize}
\begin{lstlisting}
#ifndef DEP
#define DEP

#include <string>

struct Manager;

struct Departement
{
	Manager* mgr;//not allocated here
	std::string nom;

	Departement(std::string nom, Manager* mgr = nullptr);	
};

#endif
\end{lstlisting}
\begin{lstlisting}
#include "departement.h"

Departement::Departement(std::string nom, Manager* mgr) : nom(nom), mgr(mgr) {}
\end{lstlisting}
\end{frame}

\begin{frame}[containsverbatim]
\frametitle{Exemple}
\begin{itemize}
\item Fichiers \texttt{manager.*}, \texttt{departement.*} et \texttt{mag-dep-main.cpp}
\end{itemize}
\begin{lstlisting}
#ifndef MAG
#define MAG

#include <string>
#include "departement.h"

struct Manager
{
	Departement& dpt;
	std::string nom;
	
	Manager(std::string nom, Departement& dpt);
};

#endif
\end{lstlisting}
\begin{lstlisting}
#include "manager.h"

Manager::Manager(std::string nom, Departement& dpt) : nom(nom), dpt(dpt) {}
\end{lstlisting}
\end{frame}

\end{document}
